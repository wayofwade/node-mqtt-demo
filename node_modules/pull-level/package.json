{
  "_args": [
    [
      {
        "raw": "pull-level@^2.0.3",
        "scope": null,
        "escapedName": "pull-level",
        "name": "pull-level",
        "rawSpec": "^2.0.3",
        "spec": ">=2.0.3 <3.0.0",
        "type": "range"
      },
      "/Users/chencc/work/WebstormProjects/node-mqtt/node_modules/level-sublevel"
    ]
  ],
  "_from": "pull-level@>=2.0.3 <3.0.0",
  "_id": "pull-level@2.0.4",
  "_inCache": true,
  "_location": "/pull-level",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/pull-level_2.0.4_1518373124638_0.8481198401899908"
  },
  "_npmUser": {
    "name": "dominictarr",
    "email": "dominic.tarr@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "pull-level@^2.0.3",
    "scope": null,
    "escapedName": "pull-level",
    "name": "pull-level",
    "rawSpec": "^2.0.3",
    "spec": ">=2.0.3 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/level-sublevel"
  ],
  "_resolved": "https://registry.npmjs.org/pull-level/-/pull-level-2.0.4.tgz",
  "_shasum": "4822e61757c10bdcc7cf4a03af04c92734c9afac",
  "_shrinkwrap": null,
  "_spec": "pull-level@^2.0.3",
  "_where": "/Users/chencc/work/WebstormProjects/node-mqtt/node_modules/level-sublevel",
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "bugs": {
    "url": "https://github.com/dominictarr/pull-level/issues"
  },
  "dependencies": {
    "level-post": "^1.0.7",
    "pull-cat": "^1.1.9",
    "pull-live": "^1.0.1",
    "pull-pushable": "^2.0.0",
    "pull-stream": "^3.4.0",
    "pull-window": "^2.1.4",
    "stream-to-pull-stream": "^1.7.1"
  },
  "description": "pull-stream interface to levelup",
  "devDependencies": {
    "level": "^1.4.0",
    "level-sublevel": "^6.5.4",
    "monotonic-timestamp": "0.0.8",
    "rimraf": "~2.1.4",
    "tape": "^4.5.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-fW6pljDeUThpq5KXwKbRG3X7Ogk3vc75d5OQU/TvXXui65ykm+Bn+fiktg+MOx2jJ85cd+sheufPL+rw9QSVZg==",
    "shasum": "4822e61757c10bdcc7cf4a03af04c92734c9afac",
    "tarball": "https://registry.npmjs.org/pull-level/-/pull-level-2.0.4.tgz",
    "fileCount": 14,
    "unpackedSize": 15511
  },
  "gitHead": "401569cfd4e3ba4e713bcb75091d55d4d7a0ac6b",
  "homepage": "https://github.com/dominictarr/pull-level",
  "license": "MIT",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "name": "pull-level",
  "optionalDependencies": {},
  "readme": "# pull-level\n\n[pull-stream](https://github.com/dominictarr/pull-stream) interface to\n[levelup](https://github.com/rvagg/node-levelup)\n\n## Example - reading\n\nread items in database.\n\n``` js\nvar pl = require('pull-level')\nvar pull = require('pull-stream')\n\nvar db = require('levelup')('/tmp/pull-level-example')\n\npull(pl.read(db), pull.collect(console.log))\n```\n\nread items in database, plus realtime changes\n\n``` js\npull(\n  pl.read(db, {live: true}),\n  //log data as it comes,\n  //because tail will keep the connection open\n  //so we'll never see the end otherwise.\n  pull.through(console.log),\n  //note, pull-streams will not drain unless something is\n  //pulling the data through, so we have to add drain\n  //even though the data we want is coming from pull.through()\n  pull.drain()\n)\n```\n\nIf you just want the realtime inserts,\nuse `live`\n\n``` js\npull(\n  pl.live(db, {live: true}),\n  pull.through(console.log),\n  pull.drain()\n)\n```\n\n## Example - writing\n\nTo write, pipe batch changes into `write`\n\n``` js\npull(\n  pull.values([\n    {key: 0, value: 'zero', type: 'put'},\n    {key: 1, value: 'one',  type: 'put'},\n    {key: 2, value: 'two',  type: 'put'},\n  ]),\n  pl.write(db)\n)\n```\n\nIf you are lazy/busy, you can leave off `type`.\nIn that case, if `value` is non-null, the change\nis considered a `put` else, a `del`.\n\n``` js\npull(\n  pull.values([\n    {key: 0, value: 'zero'},\n    {key: 1, value: 'one'},\n    {key: 2, value: 'two'},\n  ]), \n  pl.write(db)\n)\n```\n\n\n## Example - indexes!\n\nWith pull-level it's easy to create indexes.\njust save a pointer to the key.\n\nlike this:\n``` js\npull(\n  pull.values([\n    {key: key, value: VALUE, type: 'put'},\n    {key: '~INDEX~' + VALUE.prop, value: key,  type: 'put'},\n  ]),\n  pl.write(db)\n)\n```\n\nthen, when you want to do a `read`, use `asyncMap`\n\n``` js\npull(\n  pl.read(db, {min: '~INDEX~', max: '~INDEX~~'})\n  pull.asyncMap(function (e, cb) {\n    db.get(e.value, function (value) {\n      cb(null, {key: e.value, value: value})\n    })\n  }),\n  pull.collect(console.log)\n)\n```\n\n## Example realtime aggregation\n\nWe want to keep a realtime count of everything in the database.\nWhen ever something is inserted, we increment. But, we need\nto check the records that are *currently* in the database.\n\nSince it takes some time to scan the database, we need to make sure\nwe have done that before giving an answer. We can read it all with\none stream, using `{sync: true}` to be notified of when we have read out all the old records.\n\nFirst all the old records are read from the non-live stream,\nthen you get one `{sync: true}` element, then all the new item.\n\n``` js\nvar sum = 0, ready = false, waiting = []\n\n//call get count to know s\nfunction getSum (cb) {\n  if(!ready) waiting.push(cb)\n  else cb(null, sum)\n}\n\npull(\n  pl.read(db, {sync: true}),\n  pull.drain(function (op) {\n    if(op.sync) {\n      //if we see a data element with this it means\n      ready = true\n      while(waiting.length) waiting.shift()(null, count)\n    }\n    //increment our counter!\n    if(Number.isFinite(+op.value.amount)) //filter out non numbers & NaN.\n      sum += op.value.amount\n  })\n)\n\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/pull-level.git"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "version": "2.0.4"
}
