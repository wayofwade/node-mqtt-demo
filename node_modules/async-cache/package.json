{
  "_args": [
    [
      {
        "raw": "async-cache@~1.1.0",
        "scope": null,
        "escapedName": "async-cache",
        "name": "async-cache",
        "rawSpec": "~1.1.0",
        "spec": ">=1.1.0 <1.2.0",
        "type": "range"
      },
      "/Users/chencc/work/WebstormProjects/node-mqtt/node_modules/st"
    ]
  ],
  "_from": "async-cache@>=1.1.0 <1.2.0",
  "_id": "async-cache@1.1.0",
  "_inCache": true,
  "_location": "/async-cache",
  "_nodeVersion": "5.6.0",
  "_npmOperationalInternal": {
    "host": "packages-13-west.internal.npmjs.com",
    "tmp": "tmp/async-cache-1.1.0.tgz_1458355738878_0.8185454660560936"
  },
  "_npmUser": {
    "name": "isaacs",
    "email": "i@izs.me"
  },
  "_npmVersion": "3.7.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "async-cache@~1.1.0",
    "scope": null,
    "escapedName": "async-cache",
    "name": "async-cache",
    "rawSpec": "~1.1.0",
    "spec": ">=1.1.0 <1.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/st"
  ],
  "_resolved": "https://registry.npmjs.org/async-cache/-/async-cache-1.1.0.tgz",
  "_shasum": "4a9a5a89d065ec5d8e5254bd9ee96ba76c532b5a",
  "_shrinkwrap": null,
  "_spec": "async-cache@~1.1.0",
  "_where": "/Users/chencc/work/WebstormProjects/node-mqtt/node_modules/st",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "bugs": {
    "url": "https://github.com/isaacs/async-cache/issues"
  },
  "dependencies": {
    "lru-cache": "^4.0.0"
  },
  "description": "Cache your async lookups and don't fetch the same thing more than necessary.",
  "devDependencies": {
    "standard": "^3.11.0",
    "tap": "^2.0.0"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "4a9a5a89d065ec5d8e5254bd9ee96ba76c532b5a",
    "tarball": "https://registry.npmjs.org/async-cache/-/async-cache-1.1.0.tgz"
  },
  "files": [
    "ac.js"
  ],
  "gitHead": "d8a0e9a2cd0332e380e9459591f18402828f975a",
  "homepage": "https://github.com/isaacs/async-cache#readme",
  "keywords": [
    "async",
    "cache",
    "lru"
  ],
  "license": "ISC",
  "main": "ac.js",
  "maintainers": [
    {
      "name": "isaacs",
      "email": "i@izs.me"
    }
  ],
  "name": "async-cache",
  "optionalDependencies": {},
  "readme": "# async-cache\n\nCache your async lookups and don't fetch the same thing more than\nnecessary.\n\n## Example\n\nLet's say you have to look up stat info from paths.  But you are ok\nwith only looking up the stat info once every 10 minutes (since it\ndoesn't change that often), and you want to limit your cache size to\n1000 objects, and never have two stat calls for the same file\nhappening at the same time (since that's silly and unnecessary).\n\nYou can do this:\n\n```javascript\nvar stats = new AsyncCache({\n  // options passed directly to the internal lru cache\n  max: 1000,\n  maxAge: 1000 * 60 * 10,\n  // method to load a thing if it's not in the cache.\n  // key must be unique in the context of this cache.\n  load: function (key, cb) {\n    // the key can be something like the path, or fd+path, or whatever.\n    // something that will be unique.\n    // this method will only be called if it's not already in cache, and will\n    // cache the result in the lru.\n    getTheStatFromTheKey(key, cb)\n  }\n})\n\n// then later..\nstats.get(fd + ':' + path, function (er, stat) {\n  // maybe loaded from cache, maybe just fetched\n})\n```\n\nExcept for the `load` method, all the options are passed unmolested to\nthe internal [lru-cache](http://npm.im/lru-cache).\n\n### Differences from [lru-cache](http://npm.im/lru-cache)\n\nSince values are fetched asynchronously, the `get` method takes a\ncallback, rather than returning the value synchronously.\n\nWhile there is a `set(k,v)` method to manually seed the cache,\ntypically you'll just call `get` and let the load function fetch the\nkey for you.\n\nKeys must uniquely identify a single object, and must contain all the\ninformation required to fetch an object, and must be strings.\n\n### Per key `maxAge`\n\nIf `load` callback is called with 3 arguments, the 3rd is passed to\nthe internal [lru-cache](http://npm.im/lru-cache) as a `maxAge` for\nthe retrieved key.\n\n```javascript\n  function load (key, cb) {\n    getValueFromTheKey(key, function (err, item) {\n      cb(err, item.value, item.maxAge)\n    })\n  }\n```\n\n## Methods\n\n* `get(key, cb)` If the key is in the cache, then calls `cb(null,\n  cached)` on nextTick.  Otherwise, calls the `load` function that was\n  supplied in the options object.  If it doesn't return an error, then\n  cache the result.  Multiple `get` calls with the same key will only\n  ever have a single `load` call at the same time.\n\n* `set(key, val, maxAge)` Seed the cache.  This doesn't have to be done, but\n  can be convenient if you know that something will be fetched soon.\n  `maxAge` is optional - it is passed to internal LRU cache\n\n* `reset()` Drop all the items in the cache.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/async-cache.git"
  },
  "scripts": {
    "test": "standard && tap test/*.js --cov"
  },
  "version": "1.1.0"
}
